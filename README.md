
# Conflux Simulator

## Overview

This is a conflux simulator. It contains an **oracle** and arbitrary number of **miners**. The oracle simulates two things:

- PoW result: the oracle will determine the generation time and the miner of each block. In order to simulate PoW. 
- Network delay: the miner can only broadcast its block by notifying oracle. The oracle will determine the receiving time of each peer. 

In the implementation, the oracle maintains a priority queue of **events**. Each event has a `timestamp` and a function `run()` which outputs a list of new events. The oracle execute events in time sequence and add the new events to the events queue. 

## Code explanation

### Miner

```
type Miner interface {
	Setup(*Oracle)
	ReceiveBlock(*Block) ([]Event)
	GenerateBlock(*Block) ([]Event) 
}
```
Each miner should implements the following three interfaces, which will be called by oracle in executing events.
- `Setup`: Executed when added to oracle. Called by `addMiner` of `Oracle`.
- `GenerateBlock`: The oracle tells the miner that it generates a block, the miner should set the parent edge and reference edges in this function. 
- `ReceiveBlock`: The oracle relays a block generated by others, the miner should record this block. 


### Event
```
type Event interface {
	GetTimestamp() int64
	Run(o *Oracle) []Event
}
```
Each event should implement two functions. The oracle will order all the events in time series, execute `Run()` and insert the results to events queue. 

(Note: if the returned event has the timestamp earlier than the timestamp of current event, the event will be dropped.)

`BaseEvent` is a basis struct of all the other events.

```
type BaseEvent struct {
	timestamp int64
}

func (e *BaseEvent) GetTimestamp() int64 {
	return e.timestamp
}
```

Currently I implement four events
- `GenBlockEvent`: This event specify who and when generate the next block. The oracle will call `GenerateBlock()` for corresponding miner and generate the next `GenBlockEvent`.
- `SendBlockEvent`: This event specifies a block and its receiver. The oracle call `ReceiveBlock()` for corresponding miner. 

There are also some events work cooperated with specific miner or network. 
- `BroadcastEvent`: For `SimpleNetwork` only. It will generate `SendBlockEvent` for all the other miners according to the `SimpleNetwork` network policy.


### Network

```
type Network interface {
	Setup(*Oracle)
	Broadcast(int, *Block) []Event
	Relay(int, *Block) []Event
}
```
The network interface is used by `Oracle` and `HonestMiner`.

- `Setup`: Executed when set as the network of oracle. Called by `setNetwork` of `Oracle`.
- `Broadcast`: Called by honest miner when it generate a block. Miner will pass the results to oracle.
- `Relay`: Called by honest miner when it receives a block. Miner will pass the result to oracle.

Currently we have two network:
- `SimpleNetwork`: The network is fully connected and every package have constant network delay. (Attacker may have a lower delay.)
- `PeerNetwork`: Copied from Peilun's code. It simulates the peer to peer network. Every node have limited neighbors and bandwidth. 

### Oracle

```
type Oracle struct {
	queue   *EventQueue // Event Priority Queue
	miners  *MinerSet   // All the miners and their computational power.
	blocks  []*Block    // The list of all the mined blocks. (Including the blocks hide by attacker)
	network *Network    // Network delay simulator

	timestamp     int64    // The current timestamp in simulation
	timePrecision float64  // The number of time slots in one second 
	rate          float64  // Generation rate (seconds/block)

	duration int64         // Maximum timestamp determine when to stop 
}
```

The main loop of oracle is showed as follows: Pick one event, execute it and insert its consequences. 
```
// o is the pointer of the oracle itself
event := o.queue.Pop();
o.timestamp = (*event).getTimestamp()

if o.timestamp > o.duration {
	break
}

results := (*event).run(o)
for _, e := range results {
	if (*e).getTimestamp() >= o.timestamp {
		o.queue.Push(e)
	}
}
```

Functions called by external:
```
func NewOracle(timePrecision float64, rate float64, duration float64)
/** 
 *  timePrecision: The number of time slots in one second
 *  rate: generation rate (seconds/block)
 *  duration: The duration of this experiment (seconds)
 **/
 
func (o *Oracle) addMiner(miner Miner, weight float64)
/** 
 * weight: the computation power of this miner.
 **/
 
 func (o *Oracle) setNetwork(network Netwok, weight float64)
 /**
  * !!! IMPORTANT !!!
  * You must add all the miners before setNetwork, because some network need to be aware of all the nodes.
  */
```
### Local Graph
TBA.

## Modification Guide
### Implement an attack strategy
You can implement an attacker by writeing a struct implement `Miner` interface. Pay attention to following things.
- `generateBlock(*Block)`: In this function, you should specify the `height`, `ancestorNum`, `parent` and `references` of this block. You also need to add this block to its the `children`, `refChildren` of its `parent` and `references`. Don't touch the other parts of any blocks. The block pointers are shared by the oracle and all the miners. `oracle` will never check your behavior and prevent incorrect operation. But you can design your own local graph for free. 
- `receiveBlock(*Block)`: Oracle may send the same block more than once or send a child earlier than its parent. Deal with such case carefully. 
- Never return a `nil`, use `[]Event{}` instead. 
- You can let your attacker interact with the `network` in `oracle`. In order to allow the attacker to control the network. 

### Interact with `PeerNetwork`

TBA.
