
# Conflux Simulator

## Overview

This is a conflux simulator. It contains an **oracle** and arbitrary number of **miners**. The oracle simulates two things:

- PoW result: the oracle will determine the generation time and the miner of each block. In order to simulate PoW. 
- Network delay: the miner can only broadcast its block by notifying oracle. The oracle will determine the receiving time of each peer. 

In the implementation, the oracle maintains a priority queue of **events**. Each event has a `timestamp` and a function `run()` which outputs a list of new events. The oracle execute events in time sequence and add the new events to the events queue. 

## Code explanation

### Interfaces

#### Miner
```
type Miner interface {
	receiveBlock(*Block) ([]*Event)
	generateBlock(*Block) ([]*Event) 
	wake() ([]*Event)
}
```
Each miner should implements the following three interfaces, which will be called by oracle in executing events.
- `generateBlock`: The oracle tells the miner that it generates a block, the miner should set the parent edge and reference edges in this function. 
- `receiveBlock`: The oracle relays a block generated by others, the miner should record this block. 
- `wake`: For honest miners, they have nothing to do except generating or receiving a block. So they don't need to implement it. But it may be useful for attackers.


#### Event
```
type Event interface {
	getTimestamp() int64
	run(o *Oracle) []*Event
}
```
Each event should implement two functions. The oracle will order all the events in time series, execute `run()` and insert the results to events queue. 

(Note: if the returned event has the timestamp earlier than the timestamp of current event, the event will be dropped.)

`BaseEvent` is a basis struct of all the other events.

```
type BaseEvent struct {
	timestamp int64
}

func (e *BaseEvent) getTimestamp() int64 {
	return e.timestamp
}
```

Currently I implement four events
- `GenBlockEvent`: This event specify who and when generate the next block. The oracle will call `generateBlock()` for corresponding miner and generate the next `GenBlockEvent`.
- `SendBlockEvent`: This event specifies a block and its receiver. The oracle call `receiveBlock()` for corresponding miner. 
- `BroadcastEvent`: The miner requests the oracle to broadcast its block. The oracle will generate `SendBlockEvent` for all the other miners according to the network delay. (Introduced later)
- `WakeNodeEvent`: The oracle will call `wake()` for corresponding miner.

#### Network

```
type Network interface {
	getDelay(senderID int, receiverID int, block *Block) float64
}
```
The network interface is used to simulate the network delay. When the oracle meets a `BroadcastEvent`, it use the result from `getDelay` to determine when to execute `SendBlockEvent`.

### Oracle

```
type Oracle struct {
	queue   *EventQueue // Event Priority Queue
	miners  *MinerSet   // All the miners and their computational power.
	blocks  []*Block    // The list of all the mined blocks. (Including the blocks hide by attacker)
	network *Network    // Network delay simulator

	timestamp     int64    // The current timestamp in simulation
	timePrecision float64  // The number of time slots in one second 
	rate          float64  // Generation rate (seconds/block)

	duration int64         // Maximum timestamp determine when to stop 
}
```

The main loop of oracle is following. Pick one event, execute it and insert its consequences. 
```
// o is the pointer of the oracle itself
event := o.queue.Pop();
o.timestamp = (*event).getTimestamp()

if o.timestamp > o.duration {
	break
}

results := (*event).run(o)
for _, e := range results {
	if (*e).getTimestamp() >= o.timestamp {
		o.queue.Push(e)
	}
}
```
Two useful function:


```
func NewOracle(timePrecision float64, rate float64, duration float64)
/** 
 *  timePrecision: The number of time slots in one second
 *  rate: generation rate (seconds/block)
 *  duration: The duration of this experiment (seconds)
 **/
 
func (o *Oracle) addHonestMiner(weight float64)
/** 
 * weight: the computation power of this miner.
 **/
```
### Honest Miner
TBA.
### Simple Network
TBA.
### Local Graph
TBA.
## Modification Guide
### Implement an attack strategy
You can implement an attacker by writeing a struct implement `Miner` interface. Pay attention to following things.
- `generateBlock(*Block)`: In this function, you should specify the `height`, `ancestorNum`, `parent` and `references` of this block. You also need to add this block to its the `children` of its parents. Don't touch the other parts of any blocks. The block pointers are shared by the oracle and all the miners. `oracle` will not check your behavior and prevent incorrect operation. But you can design your own local graph for free. 
- `receiveBlock(*Block)`: Oracle may send the same block more than once or send a child earlier than its parent. Deal with such case carefully. 
- `wake()`: You can send `WakeNodeEvent` to oracle and handle it in this function. 
- Never return a `nil`, use `[]*Event{}` instead. 
- You can let your attacker interact with the `network` in `oracle`. In order to allow the attacker to control the network. 

### Get more statistics
You can add code to `run()` function of four events (in file `event.go`). So you can get more logs and record some statistics information. 

### Network setting
You can experiment the special network environment by wring your struct implements `network` interface and let  `oracle.network` point to it. 